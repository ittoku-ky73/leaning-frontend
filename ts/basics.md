# TypeScriptの基本

> 参考: https://www.typescriptlang.org/docs/handbook/2/basic-types.html

JavaScriptの各値には、様々な操作を実行することができます。簡単な例として、`message`変数を見ていきましょう。

```javascript
message.toLowerCase();
message();
```

最初の行で`toLowerCase`というプロパティにアクセスし、それを呼び出しています。2行目では`message`を直接呼び出しています。
しかし、`message`の値がわからないと仮定すると、実行結果がどうなるかわからないことがあります。これらの動作は、変数にどのような値を持たせているかに依存しているからです。

- `message`は呼び出し可能か
- `message`には`toLowerCase`というプロパティを持っているか
- もしそうなら、呼び出し可能か
- これらの値が呼び出し可能である場合、何を返すか

JavaScriptでは変数を定義するときに変数名で予想するか、頭の中で覚えておくかする必要があります。

`message`が次のように定義されていたとしましょう。

```javascript
const message = "Hello World!";
```

この変数に、`toLowerCase()`を実行すると成功しますが、`message()`を実行すると失敗します。

コードを実行するとき、JavaScriptランタイムは値の型を見ます。そのときに異常があればエラーを返します。
文字列や数値といったプリミティブな値については、`typeof`演算子で型を特定できますが、関数には、そのような機能はありません。
そのため一度関数を呼び出して見て、結果を見ることでのみ型を特定することができます。このような動作は、コードを実行する前での予想は難しくなります。

というわけで、TypeScriptの型システムはこのような場面に強いというわけです。

## 静的な型チェック

多くの人は、コードを実行するときになんらかのエラーが発生することを嫌がり、バグだと思われがちです。
もし、コードの記述量がそこまで多くなければ、さほど問題になりません。しかしそうでない場合、大規模なリファクタリングを行い、多くの異なるコードを追加したり、掘り下げたりすることがあるかもしれません。

理想は、コードが実行される前にこうしたバグを発見するツールがあればいいのです。TypeScriptの静的型チェックがあれば、プログラム実行前にバグを潰すことができます。つまり、コードを実行する前にエラーメッセ０時を表示してくれます。

## 例外処理

これまで、JavaScriptランタイムについて見てきました。ECMAScriptの仕様には予期せぬ事態に遭遇したとき、言語がどのように振る舞うかについて明示的な指示があります。
例えば、呼び出しできないものを呼び出した場合、エラーになります。しかし、呼び出しできないプロパティを呼び出した場合はエラーになりません。またエラーにならない代わりに、未定義の値`undefined`を返します。TypeScriptだとこの場合、プロパティがないよと教えてくれます。

```javascript
const user = {
  name: "Daniel",
  age: 26,
};

user.location;  // undefined
```

他にも、タイピングミス、関数の呼び出しミス、ロジックエラーなども教えてくれます。

## 型のツール

TypeScriptは、コードを書くときにミスをしたときにバグを教えてくれます。それも素晴らしいですが、そもそも間違いを起こさないようにすることもできるのです。
タイプチェッカーは、変数やプロパティに正しくアクセスしているかといったチェックをするための情報を持っています。そのおかげで、どのプロパティを使うべきかを提案してくれます（自動補完）。

これはとても便利で、テキストエディタでエラーメッセージの表示や、コード保管を自動でしてくれるというものです。

TypeScriptはツールが充実しています。テキストエディタでは、エラーを自動的に修正する「クイックフィックス」、コードを簡単に際構成するリファクタリング、変数の定義にジャンプ、指定した変数への参照の表示などを行うことができます。
これらの機能はすべてタイプチェッカーの上に構築されており、クロスプラットフォームであるため、テキストエディタにあらかじめTypeScriptのサポートが用意されている可能性が高いです。

## `tsc` TypeScript Compiler

では実際に型チェックを行って見ましょう。`npm`で`tsc`をインストールします。

```bash
npm install -g typescript
```

`hello.ts`ファイルを作成して、以下のコードを記述します。

```typescript
console.log("Hello World!!!");
```

そして、以下のコマンドで`hello.ts`を実行します。

```bash
tsc hello.ts
```

そうすると何も起こりません。なぜならエラーが起きていないからです。また、出力されない点は、`tsc`はおそらくコンパイルするためのコマンドで、出力する機能を持っていないからだと思います。
コンソールに出力させたい場合は、`ts-node`をインストールするのが良いと思います。

## エラーを吐く

JavaScriptのコードをTypeScriptの環境で実行するときに、動作しない場合があります。そのときに、先ほどの`tsc`コマンドのオプションに、`noEmitOnError`とすることで、エラーによってコードが止まることがなくなります。

```bash
tsc --noEmitOnError hello.ts
```

## 明示的な型

いくつか関数の引数に型を指定して見ましょう。

```typescript
function greet(persion: string, date: Date) {
  console.log(`Hello ${persion}, today is ${date.toDateString()}!!!`);
}
```

次に関数を使用して見ましょう。

```typescript
greet("Maddison", Date());
```

するとエディタから次のようなメッセージが表示されます。

```none
Argument of type 'string' is not assignable to parameter of type 'Date'.
```

これは、Date型で渡されるはずの引数が`string`で渡されていますと出ています。このメッセージが出たおかげで、プログラムを実行する前にバグを発見することができました。次のように書くとメッセージが消えます。

```typescript
greet("Maddison", new Date());
```

次のように、変数の定義の時に値を書く場合であれば、型は指定しない方が良いでしょう。

```typescript
let msg = "Hello There";         // o
let msg: string = "Hello There"; // x
```

## 消去されたタイプ

上記の`greet`関数のコードを、`tsc`でコンパイルするとどうなるでしょう。見て見ましょう。

```javascript
function greet(person, date) {
    console.log("Hello ".concat(person, ", today is ").concat(date.toDateString(), "!"));
}
greet("Maddison", new Date());
```

変わった点は2つあります。

1. `person, date`パラメータの型注釈がなくなっている。
2. バッククォートではなく、`.concat`メソッドで文字列に変換されている。

1つ目の変更はわかります。TypeScriptをJavaScriptで動作させるために必要な変更です。ですが2つ目はそうではありません。変更される必要のない変更です。これについて説明します。

## ダウンレベリング

テンプレート文字列は、ECMAScript2015と呼ばれるECMAScriptのバージョン機能です。デフォルトでは、TypeScriptはECMAScriptの非常に古いバージョンであるES3をターゲットにしています。ES3にはまだバッククォートによる文字列の指定ができないため、それ以外の方法で文字列を指定しているといいうわけです。

もし、ECMAScript2015にしたいという場合は、`--target es2015`オプションを指定することで、コンパイルされます。

## 厳格さ

TypeScriptには、tsconfig.jsonに`strict: true`と設定することで、JavaScriptでいう`use strict`を設定することができます。その設定で重要なものは2つあります。

**nolmplicitAny**

型指定に`any`というものがあります。これは型の推測をしないという意味になります。`nolmplicitAny`フラグをオンにすると、型注釈で`any`をしている箇所があるとエラーを吐きます。

**strictNullChecks**

デフォルトでは、`null, undefined`のような値は他のどのタイプでも割り当て可能です。これにより、一部のコードを簡単に記述できるようになりますが、処理を忘れると大量にバグが発生します。これを防ぐための設定で、`null, undefined`の処理を忘れていないかTypeScriptが教えてくれます。
